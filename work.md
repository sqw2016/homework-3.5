## 1、Vue 3.0 性能提升主要是通过哪几方面体现的？
Vue3.0 的性能提升主要体现在一下几个方面：
  1. 实例对象的优化，将以前臃肿的对象做了精简，节省了资源
  2. 数据响应式的优化，使用Proxy对象实现数据响应式，不仅性能更佳，还能监听动态添加的属性的变化，以及数组的下标和length。初始化时不用在对data中的数据进行递归处理，只在数据被访问时才对下一级属性进行响应式的处理。大大节省的资源，提高了初始化的效率。
  3. diff算法对比新旧数据的变化时，标记静态节点，在对比节点变化时，直接跳过静态节点，提高了diff算法的效率。
  4. 编译时提升静态节点的定义到render函数外面，避免render时重复生成静态节点。同时会对事件的处理函数进行缓存，避免不必要的更新
  5. tree-shaking过滤无用的代码，缩小了代码的体积。按需加载，缩短了加载资源的时间，提升了渲染效率。

## 2、Vue 3.0 所采用的 Composition Api 与 Vue 2.x使用的Options Api 有什么区别？
Vue2.x使用的Options Api在实现业务功能时，代码往往分布在多个地方，如数据在data中定义，数据的处理则往往定义在methods中，阅读代码时往往需要来回拖动滚动条，非常不利于阅读。
Vue3.0 采用的Composition Api利用函数包装业务功能，业务功能的所有信息都定义在函数内部，功能界限清晰，非常利于阅读与维护。

## 3、Proxy 相对于 Object.defineProperty 有哪些优点？
Proxy相对于 Object.defineProperty的优点：
  1. 不用对对象的每个属性进行处理，统一监听
  2. 可以监听对象属性的动态新增，删除
  3. 监听数组的索引和length属性很容易

## 4、Vue 3.0 在编译方面有哪些优化？
Vue3.0 编译方面的优化：
  1. 标记静态节点，patch对比差异时会跳过静态节点。
  2. 静态提升，将静态节点的创建提升到render函数外，避免静态节点的重复创建。
  3. 缓存事件处理函数，避免不必要的更新

## 5、Vue.js 3.0 响应式系统的实现原理？
Vue3.0响应式系统基于Proxy实现，将普通对象转化成Proxy对象，访问属性时会触发getter函数，在getter函数中收集依赖。当给对象属性重新赋值时，会触发setter函数，遍历收集的依赖，逐个进行更新。